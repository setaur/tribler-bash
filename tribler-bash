#!/bin/bash
# Tribler API Docs:
# https://tribler.readthedocs.io/en/latest/restapi/downloads.html#

tribler_dir="$HOME/.Tribler"

show_headline=1

set -o pipefail
DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

DEBUG_COLOR_START="$(tput setaf 1 2>/dev/null)"
DEBUG_COLOR_END="$(tput sgr 0 2>/dev/null)"
[[ "$DISABLE_COLORED_DEBUG" ]] && unset DEBUG_COLOR_START DEBUG_COLOR_END
debug() {
    #if variable DEBUG is set, then prints to stderr
    #can use standard echo parameters
    #extra parameters: -d|-t - adds date; -f - adds parent function name
    [[ "$DEBUG" ]] || return 0
    
    while [ $# -gt 0 ]; do
        case "$1" in
            -d|-t) local debug_date="[$(date +'%F %X' )] " ;;
            -f) local debug_function="{${FUNCNAME[1]}}: " ;;
            -*) [[ "${#debug_args[@]}" -eq 0 ]] && local debug_args=( )
                debug_args+=("$1") ;;
            *)  break;;
        esac
        shift
    done

    #how deep function is nested:
    local s a sep
    s="$((${#FUNCNAME[@]}-2))"
    for ((a=1;a<=s;a++)); do
	sep="${sep}[ ]"
    done

    echo "${debug_args[@]}" "${sep}${DEBUG_COLOR_START}${debug_date}${debug_function}$*${DEBUG_COLOR_END}" >&2
    #echo "${debug_args[@]}" "${DEBUG_COLOR_START}${debug_date}${debug_function}$*${DEBUG_COLOR_END}" >&2
}

err() {
    [[ "${FUNCNAME[1]}" ]] && echo -n "{${FUNCNAME[1]}}: " >&2
    echo "$@" >&2
}

estimate_time() {
    #converts seconds to human readable estimtion, i.e. 2w
    local t
    t="$1"

    [[ "$t" =~ ^[0-9]*\.[0-9]+$ ]] && t="${t%.*}" #remove all digits after dot .
	
    if ! [[ "$t" =~ ^[0-9]+$ ]]; then
	echo "-"
	return 1
    fi
    
    [[ "$t" -eq 0 ]] && echo "-" && return
    
    [[ "$t" -lt 120 ]] && echo "${t}s" && return
    t=$((t/60))
    
    [[ "$t" -lt 120 ]] && echo "${t}m" && return
    t=$((t/60))
    
    [[ "$t" -lt 24 ]] && echo "${t}h" && return
    t=$((t/24))
    
    [[ "$t" -lt 7 ]] && echo "${t}d" && return
    t=$((t/7))
    
    [[ "$t" -lt 48 ]] && echo "${t}w" && return
    t=$((t/48))

    [[ "$t" -lt 100 ]] && echo "${t}y" && return
    echo forever
}

size_human_readable() {
    # $2 - optional decimal digits
    # $3 - optional round
    local digits round
    [[ "$2" ]] && digits="$2" || digits=0
    [[ "$3" ]] && round="$3"  || round='nearest'

    if ! [[ "$1" =~ ^[0-9]+$ ]]; then
	echo "'$1'"
	return
    fi
    
    numfmt --to=iec-i \
	   --suffix=B \
	   --format=" %.${digits}f" \
	   --round="${round}" "${1}" \
#	   --padding=-1 
}

jq_() { jq -e -r "$@"; }

get_api_data() {
    local version conf_file
    version="${tribler_dir}/version_history.json"
    version="$(cat "$version" | jq -e -r '.last_version' | sed 's#.0$##g' )"
    conf_file="$(find "$tribler_dir/$version" -maxdepth 1 -type f -name triblerd.conf -print -quit )"
    ls "$conf_file" >/dev/null || exit 44

    (
	cd "$DIR" || exit 1
	if ! [[ -d 'bash_ini_parser' ]]; then
	    echo "Downloading bash_ini_parser to parse tribler config file..."
	    git clone 'https://github.com/rudimeier/bash_ini_parser.git' || exit
	fi
    )
    source "$DIR"/bash_ini_parser/read_ini.sh || { err "Error running read_ini!"; exit 2; }
    read_ini "$conf_file"
    debug -f "$INI__ALL_VARS"

    default_hops="$INI__download_defaults__number_hops"
    if [[ "$default_hops" -eq 0 ]]; then
	err "Default hops=0!"
	err "not secure!"
	exit 2
    fi
    
    apikey="$INI__api__key"
    if ! [[ "$apikey" ]]; then
	echo "no apikey!" >&2
	return 1
    else
	debug -f "apikey=$apikey"
    fi
    
    apiport="$INI__api__http_port"
    if ! [[ "$apiport" ]]; then
	echo "no apiport!" >&2
	return 2
    else
	debug -f "apiport=$apiport"
    fi
}

populate_basics() {
    #if missing, populates basic vars from tribler config file or from tribler settings
    local var
    for var in "$apikey" "$default_hops" "$apiport"; do
	if ! [[ "$var" ]]; then
	    debug -f "some data missing, running get_api_data"
	    get_api_data
	    break
	fi
    done

    [[ "$default_destination_path" ]] && return 0
    debug -f curl
    tribler_settings_curl="$(curl -s -X GET -H "X-Api-Key: $apikey" http://localhost:"$apiport"/settings )" || return
    default_destination_path="$( echo "$tribler_settings_curl" | jq_ .settings.download_defaults.saveas )"
    debug -f "default_destination_path=$default_destination_path"
    [[ "$default_destination_path" ]] || exit 1
}

curl_get_downloads() {
    populate_basics
    debug -f curl
    curl -s -X GET \
	 -H "X-Api-Key: $apikey" \
	 -H  "accept: application/json" \
	 http://localhost:"$apiport"/downloads
}

populate_downloads_data() {
    #populate global vars and arrays with current data about Tribler downloads
    
    debug ''; debug -f "start"
    populate_basics

#    [[ "$DEBUG" ]] && { set -x; SET_X=1; }
    if ! [[ "$last_checktime" && ( "$(( $SECONDS-$last_checktime ))" -le 2 ) ]]; then
	debug -f "getting download data"
        # skip this section if last check not long ago
        download_data="$(curl_get_downloads )"
        last_checktime="$SECONDS"

	debug -f "processing download data"
	debug -f "populating array Hashes_all"
        Hashes_all=( $(echo "$download_data" | jq -r -c ".downloads[].infohash") )
	debug -f "Hashes_all: ${Hashes_all[*]}"

        if ! [[ "${Hashes_all[*]}" ]]; then
            debug -f "No torrents active"
            return 0
        fi

	debug -f "Setting indexes"
	declare -g -A Index
	local i hash
	i=1
	for hash in "${Hashes_all[@]}"; do
	    Index[$i]="$hash"
	    debug -f "Index[$i]=$hash"
	    i=$((i+1))
	done

	debug -f "Getting key names"
        mapfile -t Keys_download < <(echo "$download_data" | jq -r -c ".downloads[0] | keys | .[]")
        debug -f "Keys_download=${Keys_download[*]}"
    else
	debug -f "Last check not long time ago, skipping."
    fi

    local hash associative_table_name key value

    debug -f "Populating associative arrays"
    for hash in "${Hashes_all[@]}"; do

        [[ "$hash" && "$hash" =~ ^[a-zA-Z_0-9]+$ ]] ||\
            { err "empty or invalid chars in hash: '$hash'"; return 2; }
	
        associative_table_name="hash_${hash}"
        declare -g -A "${associative_table_name}"
	debug "declare -g -A \"${associative_table_name}\""

        for key in "${Keys_download[@]}"; do
	    value="$(echo "$download_data" | jq -r -c ".downloads[] | select(.infohash | contains(\"${hash}\")) | .$key" )"
	    debug -f "declare \"${associative_table_name}\"[\"$key\"]=\"$value\""
            declare -g "${associative_table_name}"["$key"]="$value"
        done
    done
#    [[ "$SET_X" ]] && { set +x; unset SET_X; }
    debug -f -e "end\n"
}

get_download_data() {
    # parameters:
    # $1 - infohash, $2 - key (from json, i.e.: name, eta, hops, speed_up etc.
    # Show selected data from associative array 'hash_$INFOHASH[$key]'
    local hash key value associative_table_name associative_query
#    debug ''; debug -f "start"
    
    hash="$1"; key="$2"
    [[ " ${Hashes_all[*]} " == *" ${hash} "* ]] || { err "invalid hash '$hash'"; return 1; }
    [[ " ${Keys_download[*]} " == *" ${key} "* ]] ||\
        { err -e "invalid key '$key'. Available keys:\n${Keys_download[*]}"; return 1; }

#    [[ "$DEBUG" ]] && set -x
    associative_table_name="hash_${hash}"
    associative_query="${associative_table_name}[${key}]"
    value="${!associative_query}"

    debug -f "$hash $key = '$value'"
    echo "$value"
#    [[ "$DEBUG" ]] && set +x
#    debug -f -e 'end\n'
}

print_values() {
    #print values of keys from json data on torrents from array $Hashes
    #if $1 = '--list-keys'; then only lists all keys
    #args: KEY1 [KEY2 [...] ]
    debug ''; debug -f "start"
    populate_basics
    [[ "${Keys_download[*]}" ]] || populate_downloads_data

    local key line hash value
    
    if [[ "$1" == '--list-keys' ]]; then
	echo "${Keys_download[*]}"
	return
    elif ! [[ "${Hashes[*]}" ]]; then
	debug -f "empty Hashes array!"
	err "No torrents selected!"
	exit 1
    fi

    {
	#Header
	if [[ "$show_headline" ]]; then
	    for key in "$@"; do
		if ! [[ " ${Keys_download[*]} " == *" ${key} "* ]]; then
		    err -e "invalid key '$key'. Available keys:\n${Keys_download[*]}"
		    exit 1
		elif ! [[ "$line" ]]; then
		    line="$key"
		else
		    line="${line}\t${key}"
		fi
	    done
	    echo -e "${line}" | tr '[:lower:]' '[:upper:]'
	fi
	
	for hash in "${Hashes[@]}"; do
	    unset line    
	    for key in "$@"; do
		value="$(get_download_data "$hash" "$key")" || return 1
	    	if ! [[ "$line" ]]; then
		    line="$value"
		else
		    line="${line}\t${value}"
		fi
	    done
	    echo -e "$line"
	done
    } | column -t -s $'\t'
}

list() {
    # shows chosen data about all Tribler downloads in human readable format
    debug ''; debug -f "start"
    populate_downloads_data

    local hash name perc size size_downloaded speed_down speed_up status ratio eta hops index

    command -v numfmt >/dev/null || { err "not installed: numfmt !"; exit 1; }

    {
	[[ "$show_headline" ]] && echo -e \
"#\t\
HASH\t\
NAME\t\
SEEDS\t\
PEERS\t\
PROGRESS\t\
STATUS\t\
SIZE\t\
 \t\
 \t\
SPEED\t\
 \t\
 \t\
ETA\t\
RATIO\t\
HOPS"
    
	for hash in "${Hashes_all[@]}"; do
	    for ((index=1;index<="${#Index[@]}";index++)); do
		[[ "${Index[$index]}" == "$hash" ]] && break
	    done
            name="'$(get_download_data "$hash" name)'"
            eta="$(estimate_time "$(get_download_data "$hash" eta)" )"
            perc="$(echo "scale=2; $(get_download_data "$hash" progress)*100/1" | bc -l )" #%
            #size="$(echo "scale=2; $(get_download_data "$hash" size)/(1024^2)" | bc -l )" #MB
            #size="$(( $(get_download_data "$hash" size)/(1024*1024) ))MB"
	    seeds="$(get_download_data "$hash" num_connected_seeds) ($(get_download_data "$hash" num_seeds))"
	    peers="$(get_download_data "$hash" num_connected_peers) ($(get_download_data "$hash" num_peers))"
            size="$(size_human_readable "$(get_download_data "$hash" size)" 2 )"
            size_downloaded="$(echo "$(get_download_data "$hash" progress)*$(get_download_data "$hash" size)/1" | bc)"
            size_downloaded="$(size_human_readable "$size_downloaded" 2 )"
            speed_down="$(size_human_readable "$(get_download_data "$hash" speed_down)" )/s"
            speed_up="$(size_human_readable "$(get_download_data "$hash" speed_up)" )/s"
            status="$(get_download_data "$hash" status | sed 's/^DLSTATUS_//' | tr '[:upper:]' '[:lower:]' )"
            ratio="$(echo "$(get_download_data "$hash" ratio)*100/1" | bc )" #%
            hops="$(get_download_data "$hash" hops)" #%
            echo -e \
"${index}\t\
${hash}\t\
${name}\t\
${seeds}\t\
${peers}\t\
${perc}%\t\
${status}\t\
[ ${size_downloaded}\t\
/\t\
${size} ]\t\
[ ↓${speed_down}\t\
/\t\
↑${speed_up} ]\t\
${eta}\t\
R:${ratio}%\t\
H:${hops}"
        
	done
    } | column -t -s $'\t'

    debug -e -f 'end\n'
}    

curl_put_download() {
    populate_basics
    debug -f curl
    curl -s -X PUT "http://localhost:$apiport/downloads" \
	 -H "accept: application/json" \
	 -H  "X-Api-Key: $apikey" \
	 -H  "Content-Type: application/json" \
	 -d "{  \"destination\": \"${default_destination_path}\",  \"anon_hops\": ${default_hops},  \"safe_seeding\": true,  \"uri\": \"${1}\"}"
}

add_torrent() {
    debug ''; debug -f "start"
    populate_basics
    local curl_out first_key started
    [[ "$DEBUG" ]] && set -x
    curl_out="$(curl_put_download "$1" )"
    first_key="$(echo "[${curl_out}]" | jq -n -e -r "inputs[] | keys[]" )"
    [[ "$DEBUG" ]] && set +x
    if [[ "$first_key" = error ]]; then
	err -n "Error!"
	echo "$curl_out" | jq_ ".${first_key}"
	exit 1
    fi
    debug -f "curl_out=${curl_out}"
    
    started="$(echo "$curl_out" | jq_ '.started' )"
    infohash="$(echo "$curl_out" | jq_ '.infohash' )"
    if ! [[ "$infohash" ]]; then
	err "no infohash!"
	return 1
    fi
    echo "$infohash - added."
    debug -e -f "end\n"
}

select_torrent() {
    # select specific torrent by index or hash, args: - hash|index
    debug ''; debug -f "start"
    populate_downloads_data

    local arg hash

    if [[ $# == 1 && "$1" == 'all' ]]; then
	debug -f "special keyword 'all', selecting all torrents"
	Hashes=( "${Hashes_all[@]}" )
	return 0
    fi
    
    for arg in "$@"; do
	if [[ "$arg" =~ ^[0-9]{1,6}$ ]]; then
	    debug -f "Treat '$arg' as index"
	    [[ "$arg" -ge 1 && "$arg" -le "${#Index[@]}" ]] || { err "Index:$arg out of range!"; exit 1; }
	    hash="${Index[$arg]}"
	else
	    debug -f "Treat '$arg' as hash"
	    hash="$arg"
	    if ! [[ " ${Hashes_all[*]} " == *" ${hash} "* ]]; then
		err "Hash '$hash' not in Tribler hashes!"
		return 1
	    fi
	fi
	Hashes+=( "$hash" )
    done

    debug -e -f "end\n"
}

curl_change_download_state() {
    #parameters: $1:infohash $2:payload    
    populate_basics

    debug -f curl

    curl -s -X PATCH "http://localhost:$apiport/downloads/$1" \
	 -H "accept: application/json" \
	 -H  "X-Api-Key: $apikey" \
	 -H  "Content-Type: application/json" \
	 -d "$2"

#    curl -X PATCH "http://localhost:52194/downloads/APIKEEEEY" -H  "accept: application/json" -H  "X-Api-Key: APIKEEEYYY" -H  "Content-Type: application/json" -d "{  \"selected_files\": [    0  ],  \"anon_hops\": 0,  \"state\": \"string\"}"
}

change_download_state() {
    # changest state of all downloads from array $Hash
    # parameter: $1: resume/stop/recheck
    debug ''; debug -f "start"

    populate_downloads_data
    
    local hash action payload
    action="$1"

    [[ "${Hashes[*]}" ]] || { err "Hash not selected!"; return 1; }
    [[ "$action" ]] || { err "action needed!"; return 1; }

    while [[ "$#" -gt 0 ]]; do
	case "$action" in
	    hops)
		hops="$2"
		[[ "$hops" =~ ^[0-3]$ ]] || { err "Invalid hops='$hops'. Must be integer 0-3"; return 1; }
		[[ "$hops" -eq 0 ]] && echo -e '\nHOPS=0 - NOT SECURE!\n'
		shift
		;;
	    start|resume) state=resume ;;
	    stop|pause) state=stop ;;
	    recheck) state=recheck ;;
	    *)
		err -e "Invalid action: '$state'\nCan be: start|resume,stop|pause,recheck\n or hops HOPS_NUMBER"
		return 1
		;;
	esac
	shift
    done

    [[ "$state" ]] && payload=" \"state\": \"$2\" "
    if [[ "$hops" ]]; then
	[[ "$payload" ]] && payload="${payload}, "
	payload="\"anon_hops\": $hops"
    fi
    payload="{ ${payload} }"

    for hash in "${Hashes[@]}"; do
	curl_change_download_state "$hash" "$payload"
    done

    debug -f -e 'end\n'
}

curl_remove() {
    # removes torrent from Tribler
    # parameters: $1:hash, if $2 exists, then remove data from disk
    populate_basics
    
    local remove_data
    if [[ "$2" ]]; then remove_data=true; else remove_data=false; fi
    
    debug -f curl
    curl -s -X DELETE "http://localhost:$apiport/downloads/$1" \
	 -H "accept: application/json" \
	 -H  "X-Api-Key: $apikey" \
	 -H  "Content-Type: application/json" \
	 -d "{  \"remove_data\": $remove_data}"

    #    curl -X DELETE "http://localhost:52194/downloads/6d4795dee70aeb88e03e5336ca7c9fcf0a1e206d" -H  "accept: application/json" -H  "X-Api-Key: CENZORED" -H  "Content-Type: application/json" -d "{  \"remove_data\": true}"
}

remove_torrent() {
    # removes all torrents from $Hashes array
    # parameters: if $1=remove_data; then removes also data on disk
    debug ''; debug -f "start"
    populate_downloads_data

    local remove_data
    
    [[ "${Hashes[*]}" ]] || { err "Hash not selected!"; return 1; }
    [[ "$1" == remove_data ]] && remove_data="$1"
    
    
    for hash in "${Hashes[@]}"; do
	curl_remove "$hash" $remove_data
    done
    debug -f -e 'end\n'
}

help() {
    echo -e \
"tribler-bash - command line interface for Tribler torrent client
\tProvides all basic functionalites needed for command line usage
Usage:
\t tribler-bash [PAR1]... COMMAND

COMMANDS:
Without any arguments - the same as 'list' command"
    echo -e \
"  list\t Show current Tribler torrents.
 \t Parameter '--no-headline' disables headline. 
 \t ___
  start TORRENT_ID [TORRENT_ID]...\t Start downloading chosen torrent(s) 
  stop,pause TORRENT_ID [ TORRENT_ID]...\t Stop downloading chosen torrent(s)
  recheck TORRENT_ID [TORRENT_ID]...\t Recheck chosen torrent(s)
  add LINK|MAGNETLINK\t Add and start download new torrent provided 
 \t by MAGNETLINK or LINK (or path) to torrent file
 \t ___
  remove TORRENT_ID [TORRENT_ID]...\t Remove chosen torrent(s) from tribler. 
  remove-data TORRENT_ID [TORRENT_ID]...\t Remove chosen torrent(s) from tribler
 \t  alongside with disk data.
 \t ___
  hops HOPS_NUMBER TORRENT_ID [TORRENT_ID]...\t Change hop number of chosen torrent(s).
  \t HOP_NUMBER can be integer in range 0 - 3.
 \t 0 - no anonymity, 3 - best anonymity.
 \t ___
  show FIELD1[,FIELD2]... TORRENT_ID [TORRENT_ID]...\t Show specific raw data about chosen torrent(s).
 \t In example name, eta, size, infohash.
 \t Multiple fields must be separated by single comma ','
 \t Parameter '--no-headline' disables headline.
 \t ___
  show-field-names\t Show names of all fields. There must be at least one
 \t torrent in tribler for this command to run.
 \t ___
  help\t Show this help." | column -s $'\t' -t
echo -e \
"
 TORRENT_ID is an index or infohash or a special keyword 'all', which will match all torrents. 
 Index is a first column of a 'list' command output. Infohash is a hash atributed by tribler 
 to a specific torrent. Can be viewed using i.e. command
 \t '$0 show name,infohash all'

Parameters:"
echo -e \
" -h, --help\t Show this help
 -d, --debug\t Enable debug, verbose mode
 -n, --no-headline\t disables headline for 'list' and 'field' commands" | column -s $'\t' -t
echo
}

while [[ $# -gt 0 ]]; do
    debug "check if '$1' is parameter..."
    case "$1" in
        -h|--help) help; exit ;;
        -d|--debug)
	    DEBUG=1
	    debug 'Debug mode'
	    ;;
        -n|--no-headline)
	    debug 'Disable headlines'
	    unset show_headline ;;
        --)  shift; break;;
        -*)  help           
             exit 1;;
        *)
	    debug 'no more parameters'
	    break;;
    esac
    shift
done

debug "action=$1"
case "$1" in
    ''|list)
	list
	;;
    
    start|stop|pause|recheck)
	action="$1"
	shift
	select_torrent "$@"
	change_download_state "$action"
	;;

    hops)
	hops="$2"
	shift 2
	select_torrent "$@"
	change_download_state hops "$hops"
	;;

    add)
	add_torrent "$2"
	;;
    
    remove)
	shift
	select_torrent "$@"
	remove_torrent
	;;

    remove-data)
	shift
	select_torrent "$@"
	remove_torrent remove_data
	;;

    'help')
	help
	;;

    show-field-names)
	print_values --list-keys
	;;

    show)
	IFS=',' read -r -a Chosen_fields <<< "$2"
	shift 2
	select_torrent "$@"
	print_values "${Chosen_fields[@]}"
	;;
    *)
	err "Invalid action '$1'"
	help
	exit
	;;
esac
