#!/bin/bash
tribler_dir="$HOME/.Tribler"
DEBUG=1


DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

DEBUG_COLOR_START="$(tput setaf 1 2>/dev/null)"
DEBUG_COLOR_END="$(tput sgr 0 2>/dev/null)"
[[ "$DISABLE_COLORED_DEBUG" ]] && unset DEBUG_COLOR_START DEBUG_COLOR_END
debug() {
    #if variable DEBUG is set, then prints to stderr
    #can use standard echo parameters
    #extra parameters: -d,-t - adds date; -f - adds parent function name
    [[ "$DEBUG" ]] || return 0
    
    while [ $# -gt 0 ]; do
        case "$1" in
            -d|-t) local debug_date="[$(date +'%F %X' )] " ;;
            -f) local debug_function="{${FUNCNAME[1]}}: " ;;
            -*) [[ "${#debug_args[@]}" -eq 0 ]] && local debug_args=( )
                debug_args+=("$1") ;;
            *)  break;;
        esac
        shift
    done

    local s a sep
    s="$((${#FUNCNAME[@]}-2))"
    if [[ "$s" -gt 0 ]]; then
	for ((a=1;a<=s;a++)); do
	    sep="${sep}[ ]"
	done
    fi
    echo "${debug_args[@]}" "${sep}${DEBUG_COLOR_START}${debug_date}${debug_function}$*${DEBUG_COLOR_END}" >&2
    #echo "${debug_args[@]}" "${DEBUG_COLOR_START}${debug_date}${debug_function}$*${DEBUG_COLOR_END}" >&2
}

err() {
    [[ "${FUNCNAME[1]}" ]] && echo -n "{${FUNCNAME[1]}}: " >&2
    echo "$@" >&2
}

estimate_time() {
    #converts seconds to human readable estimtion, i.e. 2w
    local t
    t="$1"
    
    if ! [[ "$t" =~ ^[0-9]+$ ]]; then
	echo "'$t'"
	return
    fi
    
    [[ "$t" -eq 0 ]] && echo "-" && return
    
    [[ "$t" -lt 120 ]] && echo "${t}s" && return
    t=$((t/60))
    
    [[ "$t" -lt 120 ]] && echo "${t}m" && return
    t=$((t/60))
    
    [[ "$t" -lt 24 ]] && echo "${t}h" && return
    t=$((t/24))
    
    [[ "$t" -lt 7 ]] && echo "${t}d" && return
    t=$((t/7))
    
    [[ "$t" -lt 48 ]] && echo "${t}w" && return
    t=$((t/48))

    [[ "$t" -lt 100 ]] && echo "${t}y" && return
    echo forever
}

size_human_readable() {
    # $2 - optional decimal digits
    # $3 - optional round
    local digits round
    [[ "$2" ]] && digits="$2" || digits=0
    [[ "$3" ]] && round="$3"  || round='nearest'

    if ! [[ "$1" =~ ^[0-9]+$ ]]; then
	echo "'$1'"
	return
    fi
    
    numfmt --to=iec-i \
	   --suffix=B \
	   --format=" %.${digits}f" \
	   --round="${round}" "${1}" \
#	   --padding=-1 
}

jq_() { jq -e -r "$@"; }

get_api_data() {
    local version conf_file
    version="${tribler_dir}/version_history.json"
    version="$(cat "$version" | jq -e -r '.last_version' | sed 's#.0$##g' )"
    conf_file="$(find "$tribler_dir/$version" -maxdepth 1 -type f -name triblerd.conf -print -quit )"
    ls "$conf_file" >/dev/null || exit 44

    (
	cd "$DIR" || exit 1
	[[ -d 'bash_ini_parser' ]] || \
	    git clone 'https://github.com/rudimeier/bash_ini_parser.git'
    )
    source "$DIR"/bash_ini_parser/read_ini.sh || { err "Error running read_ini!"; exit 2; }
    read_ini "$conf_file"
    debug -f "$INI__ALL_VARS"

    default_hops="$INI__download_defaults__number_hops"
    if [[ "$default_hops" -eq 0 ]]; then
	echo "Hops=0!"
	echo "not secure!"
	exit 2
    fi
    
    apikey="$INI__api__key"
    if ! [[ "$apikey" ]]; then
	echo "no apikey!" >&2
	return 1
    else
	debug -f "apikey=$apikey"
    fi
    
    apiport="$INI__api__http_port"
    if ! [[ "$apiport" ]]; then
	echo "no apiport!" >&2
	return 2
    else
	debug -f "apiport=$apiport"
    fi
}

populate_basics() {
    #if missing, populates basic vars from tribler config file or from tribler settings
    local var
    for var in "$apikey" "$default_hops" "$apiport"; do
	if ! [[ "$var" ]]; then
	    debug -f "some data missing, running get_api_data"
	    get_api_data
	    break
	fi
    done

    [[ "$default_destination_path" ]] && return 0
    debug -f curl
    tribler_settings_curl="$(curl -s -X GET -H "X-Api-Key: $apikey" http://localhost:"$apiport"/settings )" || return
    default_destination_path="$( echo "$tribler_settings_curl" | jq_ .settings.download_defaults.saveas )"
    debug -f "default_destination_path=$default_destination_path"
    [[ "$default_destination_path" ]] || exit 1
}

curl_get_downloads() {
    populate_basics
    debug -f curl
    curl -s -X GET -H "X-Api-Key: $apikey" http://localhost:"$apiport"/downloads
}

populate_downloads_data() {
    debug ''; debug -f "start"
    populate_basics

#    [[ "$DEBUG" ]] && { set -x; SET_X=1; }
    if ! [[ "$last_checktime" && ( "$(( $SECONDS-$last_checktime ))" -le 2 ) ]]; then
        # skip this section if last check not long ago
        download_data="$(curl_get_downloads )"
        last_checktime="$SECONDS"
        
        Hashes_all=( $(echo "$download_data" | jq -r -c ".downloads[].infohash") )
#        Hashes=( "${Hashes_all[@]}" )
        if ! [[ "${Hashes_all[*]}" ]]; then
            debug -f "No torrents active"
            return 0
        fi
        mapfile -t Keys_download < <(echo "$download_data" | jq -r -c ".downloads[0] | keys | .[]")
        debug -f "Keys_download=${Keys_download[*]}"
    fi

    local hash associative_table_name key value

    for hash in "${Hashes_all[@]}"; do

        [[ "$hash" && "$hash" =~ ^[a-zA-Z_0-9]+$ ]] ||\
            { err "empty or invalid chars in hash: '$hash'"; return 2; }
	
        associative_table_name="hash_${hash}"
        declare -g -A "${associative_table_name}"
	debug "declare -g -A \"${associative_table_name}\""

        for key in "${Keys_download[@]}"; do
	    value="$(echo "$download_data" | jq -r -c ".downloads[] | select(.infohash | contains(\"${hash}\")) | .$key" )"
	    debug -f "declare \"${associative_table_name}\"[\"$key\"]=\"$value\""
            declare -g "${associative_table_name}"["$key"]="$value"
        done
    done
#    [[ "$SET_X" ]] && { set +x; unset SET_X; }
    debug -f -e "end\n"
}

get_download_data() {
    # parameters:
    # $1 - infohash, $2 - key (from json, i.e.: name, eta, hops, speed_up etc.
    # Show selected data from associative array hash_$INFOHASH
    local hash key value associative_table_name associative_query
#    debug ''; debug -f "start"
    
    hash="$1"; key="$2"
    [[ "${Hashes_all[*]}" == *"${hash}"* ]] || { err "invalid hash '$hash'"; return 1; }
    [[ "${Keys_download[*]}" == *"${key}"* ]] ||\
        { err "invalid key '$key'. Available keys:\n${Keys_download[*]}"; return 1; }

#    [[ "$DEBUG" ]] && set -x
    associative_table_name="hash_${hash}"
    associative_query="${associative_table_name}[${key}]"
    value="${!associative_query}"

    debug -f "$hash $key = '$value'"
    echo "$value"
#    [[ "$DEBUG" ]] && set +x
#    debug -f -e 'end\n'
}

list_downloads() {
    # shows chosen data about downloads from $Hashes array in human readable format
    local hash name perc size size_downloaded speed_down speed_up status ratio eta hops

    debug ''; debug -f "start"
    
    populate_downloads_data
    
    for hash in "${Hashes_all[@]}"; do

        name="'$(get_download_data "$hash" name)'"
        eta="$(estimate_time "$(get_download_data "$hash" eta)" )"
        perc="$(echo "scale=2; $(get_download_data "$hash" progress)*100/1" | bc -l )" #%
        #size="$(echo "scale=2; $(get_download_data "$hash" size)/(1024^2)" | bc -l )" #MB
        #size="$(( $(get_download_data "$hash" size)/(1024*1024) ))MB"
        size="$(size_human_readable "$(get_download_data "$hash" size)" 2 )"
        size_downloaded="$(echo "$(get_download_data "$hash" progress)*$(get_download_data "$hash" size)/1" | bc)"
        size_downloaded="$(size_human_readable "$size_downloaded" 2 )"
        speed_down="$(size_human_readable "$(get_download_data "$hash" speed_down)" )/s"
        speed_up="$(size_human_readable "$(get_download_data "$hash" speed_up)" )/s"
        status="$(get_download_data "$hash" status | sed 's/^DLSTATUS_//' | tr '[:upper:]' '[:lower:]' )"
        ratio="$(echo "$(get_download_data "$hash" ratio)*100/1" | bc )" #%
        hops="$(get_download_data "$hash" hops)" #%
        echo -e \
"${hash}\t\
${name}\t\
${perc}%\t\
${status}\t\
[ ${size_downloaded}\t\
/\t\
${size} ]\t\
↓${speed_down}\t\
↑${speed_up}\t\
${eta}\t\
R:${ratio}%\t\
H:${hops}"
        
    done | column -t -s $'\t'

    debug -e -f 'end\n'
}    

curl_put_download() {
    populate_basics
    debug -f curl
    curl -s -X PUT "http://localhost:$apiport/downloads" \
	 -H "accept: application/json" \
	 -H  "X-Api-Key: $apikey" \
	 -H  "Content-Type: application/json" \
	 -d "{  \"destination\": \"${default_destination_path}\",  \"anon_hops\": ${default_hops},  \"safe_seeding\": true,  \"uri\": \"${1}\"}"
}

download() {
    debug ''; debug -f "start"
    populate_basics
    local curl_out first_key started
    [[ "$DEBUG" ]] && set -x
    curl_out="$(curl_put_download "$1" )"
    first_key="$(echo "[${curl_out}]" | jq -n -e -r "inputs[] | keys[]" )"
    [[ "$DEBUG" ]] && set +x
    if [[ "$first_key" = error ]]; then
	err -n "Error!"
	echo "$curl_out" | jq_ ".${first_key}"
	exit 1
    fi
    debug -f "curl_out=${curl_out}"
    
    started="$(echo "$curl_out" | jq_ '.started' )"
    infohash="$(echo "$curl_out" | jq_ '.infohash' )"
    if ! [[ "$infohash" ]]; then
	err "no infohash!"
	return 1
    fi
    echo "$infohash - added."
    debug -e -f "end\n"
}

select_hash() {
    # select specific hash, $1 - hash

    debug ''; debug -f "start"

    populate_downloads_data

    local hash
    for hash in "$@"; do
	if ! [[ "${Hashes_all[*]}" == *"${hash}"* ]]; then
	    err "Hash '$hash' not in Tribler hashes!"
	    return 1
	fi
    done
    Hashes+=( "$@" )

    debug -e -f "end\n"
}

curl_change_download_state() {
    #parameters: $1:infohash $2:state : resume/stop/recheck
    
    populate_basics

    debug -f curl
    curl -s -X PATCH "http://localhost:$apiport/downloads/$1" \
	 -H "accept: application/json" \
	 -H  "X-Api-Key: $apikey" \
	 -H  "Content-Type: application/json" \
	 -d "{  \"state\": \"$2\"}"
}

change_download_state() {
    # changest state of all downloads from array $Hash
    # parameter: $1: resume/stop/recheck
    # https://tribler.readthedocs.io/en/latest/restapi/downloads.html#
    debug ''; debug -f "start"

    populate_downloads_data
    
    local hash state
    state="$1"

    [[ "${Hashes[*]}" ]] || { err "Hash not selected!"; return 1; }
    [[ "$state" ]] || { err "state needed!"; return 1; }

    case "$state" in
	start|resume) state=resume ;;
	stop|pause) state=stop ;;
	recheck) true ;;
	*)
	    err -e "Invalid state: '$state'\nCan be: start|resume,stop|pause,recheck"
	    return 1
	    ;;
    esac

    for hash in "${Hashes[@]}"; do
	curl_change_download_state "$state"
    done

    debug -f -e 'end\n'
}

#get_api_data

list_downloads

[[ "$1" ]] && download "$1"
